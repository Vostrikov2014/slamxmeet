//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

package io.openvidu.server.stt;

import com.google.protobuf.util.Timestamps;
import io.openvidu.client.OpenViduException;
import io.openvidu.client.OpenViduException.Code;
import io.openvidu.server.OpenViduServer;
import io.openvidu.server.core.Participant;
import io.openvidu.server.core.SessionEventsHandler;
import io.openvidu.server.core.SessionManager;
import io.openvidu.server.kurento.core.KurentoSession;
import io.openvidu.server.kurento.kms.Kms;
import io.openvidu.server.config.OpenviduConfigPro;
import io.openvidu.server.infrastructure.InfrastructureManager;
import io.openvidu.server.infrastructure.mncontroller.MediaNodeControllerDockerManager;
import io.openvidu.server.infrastructure.mncontroller.MediaNodeProvisioner;
import io.openvidu.server.kurento.core.KurentoSessionEventsHandlerPro;
import io.openvidu.server.stt.grpc.SpeechToTextGrpcClient;
import io.openvidu.server.stt.grpc.autogenerated.SpeechToTextDefinitions;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.stream.Collectors;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;

public class SpeechToTextManager {
    private static final Logger log = LoggerFactory.getLogger(SpeechToTextManager.class);
    @Autowired
    private SpeechToTextGrpcClient speechToTextGrpcClient;
    @Autowired
    private SessionEventsHandler sessionEventsHandler;
    @Autowired
    private SessionManager sessionManager;
    @Autowired
    private InfrastructureManager infrastructureManager;
    @Autowired
    protected OpenviduConfigPro openviduConfigPro;
    private Map<String, Map<String, ParticipantSpeechToTextSubscription>> subscribedStreams = new ConcurrentHashMap();
    private ConcurrentHashMap<String, ReadWriteLock> locks = new ConcurrentHashMap();
    private Map<String, Set<String>> mediaNodeTranscribedSessions = new ConcurrentHashMap();

    public SpeechToTextManager() {
    }

    public void subscribeToSpeechToTextMessage(String sessionId, String connectionId, String lang, String subConnectionId, Kms mediaNode) throws InterruptedException, ExecutionException, TimeoutException, IOException {
        ReadWriteLock lock = (ReadWriteLock)this.locks.computeIfAbsent(sessionId, (sId) -> {
            return new ReentrantReadWriteLock();
        });

        String masterNodeIp;
        String existingLang;
        String mediaNodeIp;
        try {
            if (!lock.readLock().tryLock(5L, TimeUnit.SECONDS)) {
                mediaNodeIp = "Timeout waiting for session " + sessionId + " lock to be available to subscribe to speech to text";
                log.error(mediaNodeIp);
                throw new OpenViduException(Code.ROOM_GENERIC_ERROR_CODE, mediaNodeIp);
            }

            try {
                Map<String, ParticipantSpeechToTextSubscription> subscriptionsByUser = (Map)this.subscribedStreams.putIfAbsent(sessionId, new ConcurrentHashMap());
                if (subscriptionsByUser != null) {
                    log.info("Session {} is already configured for speech to text", sessionId);
                } else {
                    log.info("Configuring session {} for speech to text", sessionId);
                    subscriptionsByUser = (Map)this.subscribedStreams.get(sessionId);
                }

                ParticipantSpeechToTextSubscription subscription = (ParticipantSpeechToTextSubscription)subscriptionsByUser.putIfAbsent(connectionId, new ParticipantSpeechToTextSubscription());
                if (subscription != null) {
                    log.info("Participant {} already had some active speech to text subscription", connectionId);
                } else {
                    log.info("Participant {} is subscribing to speech to text for the first time", connectionId);
                    subscription = (ParticipantSpeechToTextSubscription)subscriptionsByUser.get(connectionId);
                }

                ParticipantSpeechToTextSubscription otherSubscription = (ParticipantSpeechToTextSubscription)subscriptionsByUser.putIfAbsent(subConnectionId, new ParticipantSpeechToTextSubscription());
                if (otherSubscription != null) {
                    log.info("Participant {} {}", subConnectionId, connectionId.equals(subConnectionId) ? "is subscribing to its own stream" : "was already subscribed by other participant(s)");
                } else {
                    log.info("Participant {} is being subscribed by other participant for the first time", subConnectionId);
                    otherSubscription = (ParticipantSpeechToTextSubscription)subscriptionsByUser.get(subConnectionId);
                }

                existingLang = (String)subscription.otherStreamsSubscriptionsAndLang.putIfAbsent(subConnectionId, lang);
                if (existingLang != null) {
                    throw new OpenViduException(Code.ROOM_GENERIC_ERROR_CODE, "Already subscribed to Speech To Text events for Connection " + subConnectionId + " in language " + existingLang);
                }

                Set<String> subedConnectionIdsToLang = (Set)otherSubscription.ownStreamSubscriptionsAndLang.putIfAbsent(lang, new HashSet());
                if (subedConnectionIdsToLang != null) {
                    log.info("Participant {} was already being subscribed to speech to text in lang {} by oher participant(s)", subConnectionId, lang);
                } else {
                    log.info("Participant {} is being subscribed to speech to text in lang {} for the first time", subConnectionId, lang);
                }

                if (!((Set)otherSubscription.ownStreamSubscriptionsAndLang.get(lang)).add(connectionId)) {
                    throw new OpenViduException(Code.ROOM_GENERIC_ERROR_CODE, "Already subscribed to Speech To Text events for Connection " + subConnectionId + " in language " + existingLang);
                }
            } finally {
                lock.readLock().unlock();
            }
        } catch (InterruptedException var18) {
            masterNodeIp = "InterruptedException while waiting for session " + sessionId + " lock to be available to subscribe to speech to text";
            log.error(masterNodeIp);
            throw new OpenViduException(Code.ROOM_GENERIC_ERROR_CODE, masterNodeIp);
        }

        mediaNodeIp = mediaNode.getIp();
        if (mediaNode.getMasterNodePrivateIp() == null) {
            MediaNodeProvisioner dockerProvisioner = new MediaNodeProvisioner(this.openviduConfigPro);
            MediaNodeControllerDockerManager mncontrollerDockerManager = dockerProvisioner.getMediaNodeControllerDockerManager(mediaNodeIp);
            existingLang = mncontrollerDockerManager.getOpenViduIpForMediaNode();
            mediaNode.setMasterNodePrivateIp(existingLang);
            log.info("Media Node with IP {} using Master Node private IP {}", mediaNodeIp, existingLang);
        }

        masterNodeIp = mediaNode.getMasterNodePrivateIp();
        String token = this.generateWSUri(masterNodeIp) + "?sessionId=" + sessionId + "&secret=" + this.openviduConfigPro.getOpenViduSecret() + "&stt=true";

        try {
            this.speechToTextGrpcClient.subscribeToSpeechToText(token, sessionId, mediaNodeIp, lang, subConnectionId);
        } catch (Throwable var16) {
            this.unsubscribeFromSpeechToTextMessage(sessionId, connectionId, subConnectionId, mediaNodeIp, false);
            throw var16;
        }

        this.mediaNodeTranscribedSessions.compute(mediaNodeIp, (key, value) -> {
            if (value == null) {
                return new HashSet(Arrays.asList(sessionId));
            } else {
                value.add(sessionId);
                return value;
            }
        });
    }

    public void unsubscribeFromSpeechToTextMessage(String sessionId, String connectionId, String unsubConnectionId, String mediaNodeIp, boolean performGrpcOperation) throws ExecutionException, TimeoutException {
        ReadWriteLock lock = (ReadWriteLock)this.locks.get(sessionId);
        if (lock == null) {
            throw new OpenViduException(Code.ROOM_GENERIC_ERROR_CODE, "Session " + sessionId + " has no speech to text subscriptions");
        } else {
            String errorMessage;
            try {
                if (lock.writeLock().tryLock(5L, TimeUnit.SECONDS)) {
                    try {
                        Map<String, ParticipantSpeechToTextSubscription> subscriptionsByUser = (Map)this.subscribedStreams.get(sessionId);
                        if (subscriptionsByUser == null) {
                            errorMessage = "There is no active Speech To Text subscriptions for Session " + sessionId;
                            log.error(errorMessage);
                            throw new OpenViduException(Code.ROOM_GENERIC_ERROR_CODE, errorMessage);
                        }

                        ParticipantSpeechToTextSubscription subscription = (ParticipantSpeechToTextSubscription)subscriptionsByUser.get(connectionId);
                        String lang;
                        if (subscription == null) {
                            lang = "There is no active Speech To Text subscriptions for Connection " + connectionId;
                            log.error(lang);
                            throw new OpenViduException(Code.ROOM_GENERIC_ERROR_CODE, lang);
                        }

                        lang = (String)subscription.otherStreamsSubscriptionsAndLang.remove(unsubConnectionId);
                        if (lang != null) {
                            Set<String> langs = (Set)((ParticipantSpeechToTextSubscription)subscriptionsByUser.get(unsubConnectionId)).ownStreamSubscriptionsAndLang.get(lang);
                            langs.remove(connectionId);
                            if (langs.isEmpty()) {
                                ((ParticipantSpeechToTextSubscription)subscriptionsByUser.get(unsubConnectionId)).ownStreamSubscriptionsAndLang.remove(lang);
                                if (performGrpcOperation) {
                                    this.speechToTextGrpcClient.unsubscribeFromSpeechToText(sessionId, mediaNodeIp, lang, unsubConnectionId);
                                }
                            }
                        }

                        subscriptionsByUser.entrySet().removeIf((v) -> {
                            return ((ParticipantSpeechToTextSubscription)v.getValue()).isEmpty();
                        });
                        if (subscriptionsByUser.entrySet().isEmpty()) {
                            this.reset(sessionId, mediaNodeIp, true);
                        }
                    } finally {
                        lock.writeLock().unlock();
                    }

                } else {
                    String errMsg = "Timeout waiting for session " + sessionId + " lock to be available to unsubscribe from speech to text";
                    log.error(errMsg);
                    throw new OpenViduException(Code.ROOM_GENERIC_ERROR_CODE, errMsg);
                }
            } catch (InterruptedException var15) {
                errorMessage = "InterruptedException while waiting for session " + sessionId + " lock to be available to unsubscribe from speech to text";
                log.error(errorMessage);
                throw new OpenViduException(Code.ROOM_GENERIC_ERROR_CODE, errorMessage);
            }
        }
    }

    public void handleSpeechToTextMessage(SpeechToTextDefinitions.SpeechToTextMessage sttMessage) {
        String sessionId = sttMessage.getSessionId();
        String connectionId = sttMessage.getConnectionId();
        Map<String, ParticipantSpeechToTextSubscription> subscribedStreamsByUser = (Map)this.subscribedStreams.get(sessionId);
        Set<Participant> participantsToSendSttMessage = (Set)this.sessionManager.getParticipants(sessionId).stream().filter((p) -> {
            ParticipantSpeechToTextSubscription sub = (ParticipantSpeechToTextSubscription)subscribedStreamsByUser.get(p.getParticipantPublicId());
            if (sub == null) {
                return false;
            } else {
                String lang = (String)sub.otherStreamsSubscriptionsAndLang.get(connectionId);
                return lang != null && lang.equals(sttMessage.getLang());
            }
        }).collect(Collectors.toSet());
        ((KurentoSessionEventsHandlerPro)this.sessionEventsHandler).onSpeechToTextMessage(sessionId, connectionId, Timestamps.toMillis(sttMessage.getTimestamp()), sttMessage.getText(), sttMessage.getReason(), sttMessage.getRaw(), sttMessage.getLang(), participantsToSendSttMessage);
    }

    public void warnClientsAboutGrpcChannelDisconnection(Set<Participant> participants, String errorMessage) {
        ((KurentoSessionEventsHandlerPro)this.sessionEventsHandler).onSpeechToTextDisconnection(participants, errorMessage);
    }

    public Set<Participant> getCurrentSubscribedParticipants() {
        Set<Participant> currentSubscribedParticipants = new HashSet();
        Iterator var2 = this.subscribedStreams.keySet().iterator();

        while(var2.hasNext()) {
            String sessionId = (String)var2.next();
            Map<String, ParticipantSpeechToTextSubscription> subscribedStreamsByUser = (Map)this.subscribedStreams.get(sessionId);
            Set<Participant> participants = (Set)this.sessionManager.getParticipants(sessionId).stream().filter((p) -> {
                return subscribedStreamsByUser.containsKey(p.getParticipantPublicId());
            }).collect(Collectors.toSet());
            currentSubscribedParticipants.addAll(participants);
        }

        return currentSubscribedParticipants;
    }

    private String generateWSUri(String masterNodeIp) {
        String portStr;
        if (this.openviduConfigPro.isMultiMasterEnvironment()) {
            portStr = (String)this.openviduConfigPro.getConfigProps().get("SERVER_PORT");
            return "ws://" + masterNodeIp + ":" + portStr;
        } else {
            portStr = "";
            int port = -1;

            try {
                port = (new URI(OpenViduServer.wsUrl)).getPort();
            } catch (URISyntaxException var5) {
                log.error("Wrong URI format for property OpenViduServer.wsUrl: " + var5.getMessage());
            }

            if (port != -1) {
                portStr = ":" + port;
            }

            return "wss://" + masterNodeIp + portStr;
        }
    }

    public void reset(String sessionId, String mediaNodeIp, boolean terminateChannel) {
        this.subscribedStreams.remove(sessionId);
        this.locks.remove(sessionId);
        if (mediaNodeIp != null && this.mediaNodeTranscribedSessions.containsKey(mediaNodeIp)) {
            ((Set)this.mediaNodeTranscribedSessions.get(mediaNodeIp)).remove(sessionId);
            if (((Set)this.mediaNodeTranscribedSessions.get(mediaNodeIp)).isEmpty()) {
                this.mediaNodeTranscribedSessions.remove(mediaNodeIp);
                if (terminateChannel) {
                    this.speechToTextGrpcClient.terminateChannel(mediaNodeIp, "last unsubscription");
                }
            }
        }

    }

    public void resetMediaNode(String mediaNodeIp) {
        Kms kms = this.infrastructureManager.getKmsByIp(mediaNodeIp);
        if (kms != null) {
            Iterator<KurentoSession> it = kms.getKurentoSessions().iterator();

            while(it.hasNext()) {
                this.reset(((KurentoSession)it.next()).getSessionId(), mediaNodeIp, false);
            }
        } else {
            log.warn("Media Node with IP {} not found", mediaNodeIp);
        }

    }

    public class ParticipantSpeechToTextSubscription {
        public Map<String, Set<String>> ownStreamSubscriptionsAndLang = new HashMap();
        public Map<String, String> otherStreamsSubscriptionsAndLang = new HashMap();

        public ParticipantSpeechToTextSubscription() {
        }

        public boolean isEmpty() {
            return this.ownStreamSubscriptionsAndLang.isEmpty() && this.otherStreamsSubscriptionsAndLang.isEmpty();
        }
    }
}
