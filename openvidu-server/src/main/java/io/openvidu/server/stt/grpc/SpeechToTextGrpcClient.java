//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

package io.openvidu.server.stt.grpc;

import com.google.common.util.concurrent.ListenableFuture;
import com.google.common.util.concurrent.Striped;
import io.grpc.ManagedChannel;
import io.grpc.ManagedChannelBuilder;
import io.grpc.StatusRuntimeException;
import io.grpc.Status.Code;
import io.grpc.stub.StreamObserver;
import io.openvidu.server.core.Participant;
import io.openvidu.server.config.OpenviduConfigPro;
import io.openvidu.server.stt.SpeechToTextManager;
import io.openvidu.server.stt.grpc.autogenerated.SpeechToTextDefinitions;
import io.openvidu.server.stt.grpc.autogenerated.SpeechToTextGrpc;
import io.openvidu.server.stt.grpc.autogenerated.SpeechToTextDefinitions.LoadVoskModelRequest;
import io.openvidu.server.stt.grpc.autogenerated.SpeechToTextDefinitions.OpenChannelRequest;
import io.openvidu.server.stt.grpc.autogenerated.SpeechToTextDefinitions.SpeechToTextSubscriptionRequest;
import io.openvidu.server.stt.grpc.autogenerated.SpeechToTextDefinitions.SpeechToTextUnsubscriptionRequest;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.locks.Lock;

import io.openvidu.server.stt.grpc.GrpcChannel;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;

public class SpeechToTextGrpcClient {
    private static final Logger log = LoggerFactory.getLogger(SpeechToTextGrpcClient.class);
    @Autowired
    private SpeechToTextManager speechToTextManager;
    @Autowired
    protected OpenviduConfigPro openviduConfigPro;
    final Striped<Lock> stripedLocks = Striped.lock(5);
    private Map<String, GrpcChannel> channels = new HashMap();

    public SpeechToTextGrpcClient() {
    }

    public void openChannel(String mediaNodeIp, int port) {
        Lock lockBasedOnMediaNodeIp = (Lock)this.stripedLocks.get(mediaNodeIp);

        try {
            if (!lockBasedOnMediaNodeIp.tryLock(15L, TimeUnit.SECONDS)) {
                log.error("Timeout waiting for Media Node IP based lock ({}) to be available", mediaNodeIp);
            } else {
                try {
                    if (this.channels.containsKey(mediaNodeIp)) {
                        log.info("gRPC channel for Media Node {} already exists", mediaNodeIp);
                        ManagedChannel ch = ((GrpcChannel)this.channels.get(mediaNodeIp)).channel;
                        if (ch != null && !ch.isShutdown() && !ch.isTerminated()) {
                            return;
                        }

                        log.info("But gRPC channel for Media Node {} was closed. Re-opening it...", mediaNodeIp);
                    } else {
                        log.info("Creating gRPC channel for Media Node {}", mediaNodeIp);
                    }

                    GrpcChannel mediaNodeChannel = this.createChannel(mediaNodeIp, port);
                    this.channels.put(mediaNodeIp, mediaNodeChannel);
                    return;
                } finally {
                    log.info("gRPC channels opened after creation of {}: {}", mediaNodeIp, this.channels.keySet());
                    lockBasedOnMediaNodeIp.unlock();
                }
            }
        } catch (InterruptedException var9) {
            log.error("InterruptedException while waiting for  Media Node IP based lock ({}) to be available", mediaNodeIp);
        }

    }

    public GrpcChannel createChannel(final String mediaNodeIp, int port) {
        GrpcChannel mediaNodeChannel = new GrpcChannel();
        mediaNodeChannel.channel = ManagedChannelBuilder.forAddress(mediaNodeIp, port).usePlaintext().build();
        mediaNodeChannel.sttServiceBlockingStub = SpeechToTextGrpc.newStub(mediaNodeChannel.channel);
        mediaNodeChannel.sttServiceFutureBlockingStub = SpeechToTextGrpc.newFutureStub(mediaNodeChannel.channel);
        SpeechToTextDefinitions.OpenChannelRequest request = OpenChannelRequest.newBuilder().build();
        mediaNodeChannel.sttServiceBlockingStub.openChannel(request, new StreamObserver<SpeechToTextDefinitions.SpeechToTextMessage>() {
            public void onNext(SpeechToTextDefinitions.SpeechToTextMessage sttMessage) {
                SpeechToTextGrpcClient.this.speechToTextManager.handleSpeechToTextMessage(sttMessage);
            }

            public void onCompleted() {
                SpeechToTextGrpcClient.log.info("FINISHED");
                SpeechToTextGrpcClient.this.terminateChannel(mediaNodeIp, "onCompleted");
            }

            public void onError(Throwable t) {
                if (t instanceof StatusRuntimeException) {
                    StatusRuntimeException exception = (StatusRuntimeException)t;
                    if (Code.UNAVAILABLE.equals(exception.getStatus().getCode())) {
                        if ("Channel shutdownNow invoked".equals(exception.getStatus().getDescription())) {
                            SpeechToTextGrpcClient.log.info("gRPC channel shutdown invoked");
                        } else if ("Network closed for unknown reason".equals(exception.getStatus().getDescription())) {
                            SpeechToTextGrpcClient.log.error("gRPC channel network closed. Warning clients");
                            Set<Participant> currentSttParticipants = SpeechToTextGrpcClient.this.speechToTextManager.getCurrentSubscribedParticipants();
                            SpeechToTextGrpcClient.this.speechToTextManager.warnClientsAboutGrpcChannelDisconnection(currentSttParticipants, exception.getStatus().getDescription());
                        } else {
                            SpeechToTextGrpcClient.log.error("gRPC channel unexpected error: " + t);
                        }
                    }
                } else {
                    SpeechToTextGrpcClient.log.error("gRPC channel unexpected error: " + t);
                }

                SpeechToTextGrpcClient.this.terminateChannel(mediaNodeIp, "onError");
            }
        });
        return mediaNodeChannel;
    }

    public synchronized void terminateChannel(String mediaNodeIp, String origin) {
        Lock lockBasedOnMediaNodeIp = (Lock)this.stripedLocks.get(mediaNodeIp);
        if (!lockBasedOnMediaNodeIp.tryLock()) {
            log.warn("gRPC connection lock is busy while trying to terminate the channel with Media Node {}. Ignoring the termination", mediaNodeIp);
        } else {
            try {
                GrpcChannel mediaNodeChannel = (GrpcChannel)this.channels.remove(mediaNodeIp);
                if (mediaNodeChannel != null) {
                    if (mediaNodeChannel.channel != null && !mediaNodeChannel.channel.isShutdown()) {
                        mediaNodeChannel.channel.shutdownNow();

                        try {
                            if (mediaNodeChannel.channel.awaitTermination(60L, TimeUnit.SECONDS)) {
                                log.info("gRPC channel successfully terminated after {}", origin);
                            } else {
                                log.error("gRPC channel did not terminate in timout after {}", origin);
                            }
                        } catch (InterruptedException var9) {
                            log.error("InterruptedException while waiting for gRPC channel termination after {}: {}", origin, var9.getMessage());
                        }
                    } else {
                        log.warn("gRPC channel was already shut down");
                    }

                    this.speechToTextManager.resetMediaNode(mediaNodeIp);
                    return;
                }

                log.info("gRPC channel with origin \"{}\" for Media Node {} was already terminated", origin, mediaNodeIp);
            } finally {
                log.info("gRPC channels opened after termination of {}: {}", mediaNodeIp, this.channels.keySet());
                lockBasedOnMediaNodeIp.unlock();
            }

        }
    }

    public void subscribeToSpeechToText(String token, String sessionId, String mediaNodeIp, String lang, String connectionId) throws InterruptedException, ExecutionException, TimeoutException {
        if (!this.channelIsOpened(mediaNodeIp)) {
            this.openChannel(mediaNodeIp, this.openviduConfigPro.getSpeechToTextPort());
        }

        SpeechToTextGrpc.SpeechToTextFutureStub sttServiceFutureBlockingStub = ((GrpcChannel)this.channels.get(mediaNodeIp)).sttServiceFutureBlockingStub;
        SpeechToTextDefinitions.SpeechToTextSubscriptionRequest request = SpeechToTextSubscriptionRequest.newBuilder().setToken(token).setSessionId(sessionId).setLang(lang).setConnectionId(connectionId).build();
        ListenableFuture<SpeechToTextDefinitions.SpeechToTextSubscriptionResponse> future = sttServiceFutureBlockingStub.subscribeToSpeechToText(request);
        SpeechToTextDefinitions.SpeechToTextSubscriptionResponse response = (SpeechToTextDefinitions.SpeechToTextSubscriptionResponse)future.get(10L, TimeUnit.SECONDS);
    }

    public void unsubscribeFromSpeechToText(String session, String mediaNodeIp, String lang, String connectionId) throws InterruptedException, ExecutionException, TimeoutException {
        if (!this.channelIsOpened(mediaNodeIp)) {
            this.openChannel(mediaNodeIp, this.openviduConfigPro.getSpeechToTextPort());
        }

        SpeechToTextGrpc.SpeechToTextFutureStub sttServiceFutureBlockingStub = ((GrpcChannel)this.channels.get(mediaNodeIp)).sttServiceFutureBlockingStub;
        SpeechToTextDefinitions.SpeechToTextUnsubscriptionRequest request = SpeechToTextUnsubscriptionRequest.newBuilder().setSessionId(session).setConnectionId(connectionId).setLang(lang).build();
        ListenableFuture<SpeechToTextDefinitions.SpeechToTextUnsubscriptionResponse> future = sttServiceFutureBlockingStub.unsubscribeFromSpeechToText(request);
        SpeechToTextDefinitions.SpeechToTextUnsubscriptionResponse response = (SpeechToTextDefinitions.SpeechToTextUnsubscriptionResponse)future.get(10L, TimeUnit.SECONDS);
    }

    public void loadVoskModel(String mediaNodeIp, String lang) throws InterruptedException, ExecutionException, TimeoutException {
        if (!this.channelIsOpened(mediaNodeIp)) {
            this.openChannel(mediaNodeIp, this.openviduConfigPro.getSpeechToTextPort());
        }

        SpeechToTextGrpc.SpeechToTextFutureStub sttServiceFutureBlockingStub = ((GrpcChannel)this.channels.get(mediaNodeIp)).sttServiceFutureBlockingStub;
        SpeechToTextDefinitions.LoadVoskModelRequest request = LoadVoskModelRequest.newBuilder().setLang(lang).build();
        ListenableFuture<SpeechToTextDefinitions.LoadVoskModelResponse> future = sttServiceFutureBlockingStub.loadVoskModel(request);
        SpeechToTextDefinitions.LoadVoskModelResponse response = (SpeechToTextDefinitions.LoadVoskModelResponse)future.get(10L, TimeUnit.SECONDS);
    }

    public void unloadVoskModel(String mediaNodeIp, String lang) throws InterruptedException, ExecutionException, TimeoutException {
        if (!this.channelIsOpened(mediaNodeIp)) {
            this.openChannel(mediaNodeIp, this.openviduConfigPro.getSpeechToTextPort());
        }

        SpeechToTextGrpc.SpeechToTextFutureStub sttServiceFutureBlockingStub = ((GrpcChannel)this.channels.get(mediaNodeIp)).sttServiceFutureBlockingStub;
        SpeechToTextDefinitions.LoadVoskModelRequest request = LoadVoskModelRequest.newBuilder().setLang(lang).build();
        ListenableFuture<SpeechToTextDefinitions.LoadVoskModelResponse> future = sttServiceFutureBlockingStub.unloadVoskModel(request);
        SpeechToTextDefinitions.LoadVoskModelResponse response = (SpeechToTextDefinitions.LoadVoskModelResponse)future.get(10L, TimeUnit.SECONDS);
    }

    public boolean channelIsOpened(String mediaNodeIp) {
        GrpcChannel channel = (GrpcChannel)this.channels.get(mediaNodeIp);
        return channel != null && channel.channel != null && !channel.channel.isShutdown() && !channel.channel.isTerminated();
    }
}
